---
title: "Healthcare Insights and Sociodemographic Analysis of New York: A Comprehensive Analysis of Patient Records in 2013 and 2021"
format: pdf
author: Abel Limachi, Austin Tran, Joel Villarino, and Krish Kumar (Group 3)
editor: visual
fontsize: 10pt
geometry: margin = 1in
---

```{r, warning = FALSE, message = FALSE}
#| echo: false
library(RSQLite)
library(readr)
library(dplyr)
library(xtable)

dcon <- dbConnect(SQLite(), dbname = "finalDB.db", timeout = 10)
```

## Introduction

In the context of the ever-evolving landscape of healthcare, our choice of dataset stems from the pressing need to delve into an in-depth analysis of the heazlthcare dynamics prevailing in today's society. New York, being one of the most densely populated states in the United States, presents a unique microcosm of diverse populations and a wide spectrum of urban and rural healthcare challenges. Motivated by the significance of understanding these complexities, our research group has selected a comprehensive dataset encompassing patient records, representing healthcare interactions across various hospitals throughout New York.

The following project contains different visualizations and statistics that will provide you more information on the different social and economic factors associated with patients in the state of New York in 2013 and through 2021.

This dataset contains a wide range of healthcare-related information. It includes basic patient demographics like age, gender, race, and ethnicity; clinical data such as diagnosis and procedure codes, severity of illness, risk of mortality, and specific healthcare indicators like abortion edit and emergency department usage. Additionally, it covers financial and administrative aspects including total charges, costs, payment typology, and facility-specific information like facility ID, name, and location (represented by a 3-digit zip code). In our analysis of the dataset, we focused on specific key elements: APR Severity of Illness, Hospital County, Age Group, Gender, Race, Ethnicity, Length of Stay, Total Charges, Total Costs, and Payment Typology. These components provide a comprehensive overview of patient demographics, clinical severity, financial aspects, and hospital location, crucial for understanding healthcare dynamics and outcomes.

## Primary Dataset: Patient Records from 2013

The primary dataset that we used was obtained from the New York State Department of Health, which is the official health representative department of the state.

The dataset consists of a collection of 2,428,905 records, providing us with an extensive amount of data to work with. This rich dataset spans a spectrum of information, including patient demographics, detailed medical records, financial aspects related to their hospitalization, and critical contextual information pertinent to each patient's stay. This extensive dataset holds immense potential for generating compelling visualizations and conducting statistical analyses, offering valuable insights into the intricacies of the New York healthcare system while also providing broader insights that can contribute to the understanding of healthcare systems more generally.

## Secondary Dataset: Patient Records from 2021

The secondary dataset, like the primary one, was also obtained from the New York State Department of Health, focusing on the year 2021. This dataset had 2,493,323 records for use. The rationale for selecting this dataset is twofold:

Firstly, it allows us to track and analyze the changes in patient records across an eight-year period, offering a longitudinal perspective on the evolving healthcare landscape in New York. This longitudinal approach is crucial for understanding trends, shifts in demographic patterns, and changes in healthcare delivery and outcomes over time.Â 

Secondly, and perhaps more importantly, the year 2021 stands as a significant historical marker due to the global COVID-19 pandemic. The pandemic has had profound and far-reaching impacts on healthcare systems worldwide, and New York was one of the epicenters of this crisis. By comparing the 2013 and 2021 datasets, we can gain invaluable insights into how the pandemic has reshaped various aspects of healthcare, including patient demographics, disease prevalence, healthcare utilization patterns, and the overall strain on the healthcare system. This comparison offers a unique opportunity to assess the resilience and adaptability of the New York healthcare system in the face of one of the most significant public health challenges of the century.

## **Exploration:**

The purpose of our exploration was to understand and contextualize the large primary dataset and investigate any trends that might exhibit potential for inequality or disparity in the healthcare system. We did this by examining a few different factors: differences in severity of illness data, disparities in charges and costs, payment typology differences, and analyzing Medicare and Medicaid recipients.

We first wanted to ground our analysis in an important part of our dataset which was exploration on patients and their reported severity of illness.

# Severity of Illness

## Plot 1: Waffle Plot of Severity of Illness by Race

```{r, fig.width = 8, fig.height = 10, message = FALSE}
#| echo: false
library(waffle)
library(patchwork)
query <- dbSendQuery(dcon,"
SELECT Race, APRSeverityofIllnessCode FROM '2013data';
                     ")
IllnessCodes <- dbFetch(query, -1)
dbClearResult(query)

waffle_data1 <- data.frame(count = table(IllnessCodes$APRSeverityofIllnessCode[IllnessCodes$Race == "Black/African American"])/2500)
waffle_data2 <- data.frame(count = table(IllnessCodes$APRSeverityofIllnessCode[IllnessCodes$Race == "White"])/5000)

layout(matrix(c(1, 2), nrow = 1))

plot1 <- waffle(waffle_data1, rows = 8, size = .5, 
            colors = c("#FFEDA0", "#FEB24C", "#FC4E2A", "#BD0026"), title = "Black/African Americans")
plot2 <- waffle(waffle_data2, rows = 8, size = .5, 
            colors = c("#FFEDA0", "#FEB24C", "#FC4E2A", "#BD0026"), title = "White")

arrange.plots <- plot1 + theme(plot.title = element_text(size = 10)) + plot2 + theme(plot.title = element_text(size = 10))
arrange.plots
```

```{=tex}
\begin{center}
Figure 1: Waffle Plots Depicting Frequencies of APR Codes 
\end{center}
```
Our first plot that we used to dive into our dataset was the above Waffle Plot, which provides an insightful visualization of the severity of illness distributed by race, focusing on Black/African American and White populations.

As we can see, the plot is divided into two sections, each representing the two racial groups mentioned. Within each section, the squares are color-coded to represent four levels of the APR severity codes, ranging from level 1 (mild, such as a common cold), indicated by the lightest color, to level 4 (severe, such as life-threatening illness), indicated by the darkest color. Across the two demographics, we observe a relatively similar distribution of APR severity codes. However, it appears that white patients, on average, has a higher concentration in severity codes level 3 and 4, which leads to these patients receiving more dire and prioritized care. As such, this raises concerns over equality: we want to ensure that patients across the board regardless of race, socioeconomic status, and other demographics receive equal care without biases.

Overall, this waffle plot serves not only as a tool to visualize data but also as a starting point for deeper discussions about health equity and the structural challenges faced by different racial groups. It's a call to action for policymakers, healthcare providers, and communities to address these disparities head-on.

With this we wanted to analyze and see if location was a potential indicator for a difference in severity of illness, this then lead us to create our next visualization which is the violin plot that compares the urban area of New York City and the rural area of Western New York.

## Plot 2: Violin Plot Comparing New York City and Western New York's Severity of Illness

```{r, fig.height = 4, fig.width = 8, warning = FALSE}
#| echo: false
query <- dbSendQuery(dcon,"
SELECT *
FROM '2013data';
")
cleaned_data <- dbFetch(query, -1)
dbClearResult(query)
subsetted_data <- cleaned_data[cleaned_data$`HealthServiceArea` %in% c("New York City", "Western NY"), ]

# Load the ggplot2 library
library(ggplot2)

# Create a violin plot for APR Severity of Illness Code
ggplot(subsetted_data, aes(x = factor(`HealthServiceArea`), y = `APRSeverityofIllnessCode`, fill = `HealthServiceArea`)) +
  geom_violin() +
  labs(
    x = "Health Service Area",
    y = "APR Severity of Illness Code",
    fill = "Health Service Area",
    title = "Distribution of APR Severity of Illness Code in Patients in New York Health Service Areas"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


```

```{=tex}
\begin{center}
Figure 2: NYC and Western NY Severity of Illness Comparsion
\end{center}
```
Figure 2 delves into a detailed breakdown of hospital patients, distinguishing between those originating from New York City (NYC) and Western New York (WNY). The focus is on the distribution of patients' APR severity codes, measured on a 1 to 4 scale (1 being mild, 2 being moderate, 3 being serious, and 4 being extreme). Notably, the violin plot reveals a higher frequency of APR severity code 2 assignments for patients from NYC compared to WNY. In the context of healthcare equality, this is a potential area of concern. In the state of New York, the areas outside of NYC are significantly more rural/suburban than NYC. Likely, the distance to the nearest hospital for residents in WNY is higher than for those who live in NYC. There being a significantly lower proportion of patients with APR severity 2 from WNY suggests that patients might not be going to the hospital unless they have severe symptoms. This could lead to many WNY residents not catching certain illnesses early when compared to NYC residents, furthering an already existing divide when it comes to healthcare access between NYC and the rest of the state..

# Disparities In Charges and Costs

## Plot 3: Linear Regression Model Regarding Charges and Costs

```{r, results='asis', warning=FALSE}
#| echo: false
query <- dbSendQuery(dcon,"
SELECT *
FROM '2013data';
")
cleaned_data <- dbFetch(query, -1)
dbClearResult(query)

# Renaming the column to 'Length of Stay' for the linear model
names(cleaned_data)[names(cleaned_data) == "LengthofStay"] <- "Length of Stay"

y <- cleaned_data$`TotalCharges`
length_of_stay <- strtoi(cleaned_data$`Length of Stay`)

# Set scipen to a large value to avoid scientific notation
options(scipen = 999999999999)

# Create a scatter plot
plot(length_of_stay, y, xlab = "Length of Stay", main = "Price vs Length of Stay", ylab = "Price")

# Fit the linear model
lmfs <- lm(y ~ length_of_stay)

# Add the regression line
abline(lmfs, col = "RED")

# Reset scipen to its default value after the plot
options(scipen = 0)
```

```{=tex}
\begin{center}
Figure 3: Length of Stay on Price Regression Dotplot
\end{center}
```
```{r, results='asis', message = FALSE, warning = FALSE, comment = FALSE}
#| echo: false
summary_lmfs <- summary(lmfs)
# Assuming lmfs is your linear model
summary_lmfs <- summary(lmfs)
r_squared <- summary_lmfs$r.squared


# Manually set the row names for the coefficients
rownames(summary_lmfs$coefficients) <- c("Intercept", "Length of Stay")

# Generate the table with xtable
table_lmfs <- xtable::xtable(summary_lmfs$coefficients, caption = "Linear Model Summary")
# Set column names for the table
colnames(table_lmfs) <- c("Estimate", "Std. Error", "t value", "Pr(>|t|)")
# Print the table w/ row names 
print(table_lmfs, include.rownames = TRUE, comment = FALSE)

```

```{r, results='asis', message = FALSE, warning = FALSE}
#| echo: false

summary_lmfs <- summary(lmfs)

# Extract R-squared value
r_squared <- summary_lmfs$r.squared

r_squared_df <- data.frame(`R^2` = r_squared)

table_r_squared <- xtable::xtable(r_squared_df, caption = "Model R-Squared")

print(table_r_squared, include.rownames = FALSE, 
      sanitize.text.function = function(x){x}, comment = FALSE)

```

In our analysis of patient data for the state of New York in 2013, we conducted a linear regression to explore the impact of the length of stay on the associated price. The results revealed a statistically significant and strong positive relationship between these variables. The coefficient for length of stay that is calcualte din days was estimated at 6140.73 with a standard error of 6.622 and a remarkably high t-value of 927.39. This suggests that as the length of stay increases, there is a substantial increase in the price, a relationship supported by a p-value close to zero. The R-squared value of 0.55 indicates that approximately 55% of the price variation can be explained by the length of stay, demonstrating its relevance as a predictor. These findings provide important insights for healthcare management and policymaking, highlighting the need to consider and manage the cost implications of varying lengths of stay for New York state patients in 2013.

However, this plot was the impetus to start seeing the interaction between total charges and costs and its relationship with other identifying factors of patients.

## Plot 4: Barplots of Average Total Charges by Race 2013 vs 2021

```{r, fig.height = 6, fig.width = 5}
#| echo: false
library(ggplot2)
library(patchwork)


pregnant_womenQ <- dbSendQuery(dcon, "
    SELECT Race, TotalCharges
    FROM '2013data'
    WHERE APRMDCCode == 14 OR APRMDCCode == 15;")
pregnant_womenDF = dbFetch(pregnant_womenQ, -1)
dbClearResult(pregnant_womenQ)

plot_race2013 <- ggplot(pregnant_womenDF) + 
  aes(x = Race, y = TotalCharges) +
  stat_summary(fun = "mean", geom = "bar", fill = "salmon") +  # Calculate and plot averages
  labs(x = "Race", y = "Average Total Charges", title = "Average Total Charge by Race in 2013") +  # Customize axis labels
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        plot.title = element_text(size = 7))  # Rotate x-axis labels for


pregnant_womenQ2 <- dbSendQuery(dcon, "
    SELECT Race, TotalCharges
    FROM '2021data'
    WHERE APRMDCCode == 14 OR APRMDCCode == 15 AND Race != 'Multi-racial';")
pregnant_womenDF2 = dbFetch(pregnant_womenQ2, -1)
dbClearResult(pregnant_womenQ2)
  
plot_race2021 <- ggplot(pregnant_womenDF2) + 
  aes(x = Race, y = TotalCharges) +
  stat_summary(fun = "mean", geom = "bar", fill = "violet") +  # Calculate and plot averages
  labs(x = "Race", y = "Average Total Charges", title = "Average Total Charge by Race in 2021") +  # Customize axis labels
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        plot.title = element_text(size = 7))  # Rotate x-axis labels for


combined_plot_race <- plot_race2013 + plot_race2021
combined_plot_race

```

```{=tex}
\begin{center}
Figure 4: Barplots of Average Total Charges by Race in 2013 and 2021
\end{center}
```
In figure 4, the bar plot illustrates a compelling contrast in average total charges for hospital care among different racial groups. Notably, it highlights that individuals who identify as Black and those categorized under the "Other Races" group experience significantly higher average total charges compared to their White counterparts for their pregnancy charges. This disparity in healthcare costs sheds light on the existing inequalities within the healthcare system, prompting a critical examination of the factors contributing to these disparities and the potential need for targeted interventions to address the especially for marginalized populations of not just women on the basis of gender but also for race as well. We see that in 2021, post the COVID-19 pandemic, this disparity between average total charges of Black patients and White patients increased, showing that the pandemic potentially increased already present disparity in healthcare. We then wanted to start shifting our focus on looking at the age of patients.

## Plot 5: Facet Density Plots of Total Cost per Age-Group Buckets

```{r warning = FALSE, fig.width = 7, fig.height = 5}
#| echo: false
data_set <- read_csv("Hospital_Inpatient_Discharges__SPARCS_De-Identified___2013.csv",show_col_types = FALSE)

clean <- na.omit(data_set)

gg <- ggplot(clean, aes(x = `Total Costs`, y = ..density.., fill = `Age Group`)) +
  geom_density(alpha = 0.5) +
  facet_grid(`Age Group` ~ .) +
  labs(title = "Density Plot of Total Costs per Age-Group Bucket", x = "Total Costs", y = "Density")

gg + 
  scale_x_continuous(limits = c(0, 35000)) +
  scale_y_continuous(labels = scales::number_format(scale = 1e-3)) +
  labs(title = "Density Plot of Total Costs per Age-Group Bucket", x = "Total Costs", y = "Density (in thousands)") +
  theme_minimal()
```

```{=tex}
\begin{center}

Figure 5: Density Plots of Total Costs per Age-Groups

\end{center}
```
The density plots detailing Total Costs across different age groups --- 0-17, 18-29, 30-49, 50-69, and 70 or older --- illustrate a clear correlation between age and healthcare expenditure. For the younger cohorts (0-17 and 18-29), the costs are low and show little variation, reflecting the typically good health of these age groups and infrequent need for extensive healthcare. As we move into the middle-aged groups (30-49 and 50-69), the plots expand, indicating an increase in both the range and average of healthcare costs. This likely corresponds to the gradual appearance of chronic illnesses and the need for more regular medical care.

The most dispersed plot is seen in the 70+ group, signaling the highest variability and cost of healthcare. This suggests the presence of multiple, more complex health issues that are common in older age, requiring more frequent and often more expensive medical interventions.

These plots underscore the impact of aging on healthcare costs and highlight the importance of proactive health measures. There is a clear indication that early intervention and preventive care could significantly affect the healthcare system's financial demands, suggesting that investing in health education and preventive measures early on could mitigate the higher costs associated with aging populations. The analysis advocates for policy adjustments that address the escalating costs in the healthcare system, ensuring that as individuals age, they are supported by a robust and responsive healthcare infrastructure.

# Payment Visualizations

## Plot 6: Pie Charts of Payment Type

```{r, fig.height = 4, fig.width = 9}
#| echo: false
par(mar = c(5, 4, 4, 2) + 0.1)


cleaned_data$`PaymentTypology1` <- as.factor(cleaned_data$`PaymentTypology1`)
payments <- table(cleaned_data$`PaymentTypology1`)
pie(payments, main = "Payment Type Distribution", col = rainbow(length(payments)), labels = NA)
legend(1, 1, 1, legend = levels(cleaned_data$`PaymentTypology1`), fill = rainbow(length(payments)), cex = 0.7)

```

```{=tex}
\begin{center}
Figure 6: Pie Chart of Payment Type 
\end{center}
```
Our analysis delves into the intricacies of healthcare payments, as depicted by a comprehensive pie chart reflecting various payment types utilized by patients for hospital services. The chart initially reveals a dominance of Medicaid, Medicare, and private health insurance, indicating these as the predominant payment methods. Notably, Medicaid occupies a significant portion, underscoring its role in providing for individuals with limited financial resources. Medicare's substantial share reflects its critical support for the elderly and certain younger individuals with disabilities. The prominence of private health insurance highlights its importance in the American healthcare landscape, often associated with employment benefits.

However, the distribution also brings attention to the smaller yet significant segments such as Managed Care and Self-Pay. The Managed Care slice suggests a structured approach to healthcare, emphasizing preventive measures and cost-efficiency, while the Self-Pay category may point to gaps in healthcare coverage or a choice for those who may not want to use insurance. The presence of diverse payment sources such as Federal/State/Local/VA and the Department of Corrections indicates the healthcare system's reach, covering veterans, federal employees, and incarcerated individuals.

Building on the diverse payment types identified, we further explore the breakdown by race to uncover potential disparities. Plot 6 segments the payment types for White, Black/African American, and Other Race groups, offering a more granular view that may reflect underlying socioeconomic patterns. This breakdown by race could provide critical insights into the equity of healthcare coverage and the financial barriers different racial groups face within the healthcare system.

## Plot 7: Pie Charts of Payment Type by Race

```{r, message = FALSE}
#| echo: false
library(ggplot2)
library(gridExtra)
library(patchwork)


paymentTypeAndRaceQ <- dbSendQuery(dcon, "
                                    SELECT Race, PaymentTypology1 FROM '2013data' WHERE Race != 'Unknown';")
paymentTypeAndRaceDF <- dbFetch(paymentTypeAndRaceQ, -1)
dbClearResult(paymentTypeAndRaceQ)
#str(paymentTypeAndRaceDF)

pie_charts <- lapply(unique(paymentTypeAndRaceDF$Race), function(race) {
  data_subset <- subset(paymentTypeAndRaceDF, Race == race)
  pie_chart <- ggplot(data_subset, aes(x = "", fill = PaymentTypology1)) +
    geom_bar(width = 1) +
    coord_polar("y") +
    ggtitle(race) +
    theme_void() +
    scale_fill_brewer(palette = "Set3") +
    theme(legend.position = ifelse(race == 'Black/African American', "left", "none"),
          axis.text = element_text(size = 0),
          legend.text = element_text(size = 5)) +
    labs(fill = "Payment Type")
  
  return(pie_chart)
})
pie_charts[[1]] + pie_charts[[2]] + pie_charts[[3]] + plot_layout(ncol = 1)
```

```{=tex}
\begin{center}
Figure 7: Pie Charts on Payment Type by Race
\end{center}
```
The pie charts shed light on a stark disparity in healthcare payment types across racial lines. They show that White patients are more likely to use Medicare, which often correlates with a more secure financial status and access to retirement benefits. Meanwhile, Black/African American individuals and those from other racial backgrounds have a higher reliance on Medicaid, indicating lower income levels and less access to private or employer-sponsored health insurance. These trends aren't just numbers; they reflect real-world inequalities where minority groups often have less access to quality healthcare. The data doesn't just highlight a disparity; it points to the need for policies that address the economic and racial factors that limit healthcare options for some groups. It's an important piece of the puzzle for creating a more equitable healthcare system where coverage and quality care are accessible to all, regardless of racial background or economic standing.

# Analyzing Medicaid Recipients by Race and Borough in New York City

## Plot 8: New York City Medicaid Heat Map

```{r, fig.width = 10}
#| echo: false
query <- dbSendQuery(dcon, "
  SELECT `HospitalCounty`, Race, COUNT(*) as count
  FROM `2013data`
  WHERE `HealthServiceArea` = 'New York City' 
    AND Race IN ('Black/African American', 'White')
  GROUP BY `HospitalCounty`, `Race`
")


data <- dbFetch(query, -1)

ggplot(data, aes(x = `HospitalCounty`, y = `Race`, fill = count)) +
  geom_tile() +
  scale_fill_gradient(low = "white", high = "red") +
  labs(title = "Number of White and Black/Other Race Individuals on Medicaid in NYC", 
       x = "Borough", 
       y = "Race", 
       fill = "Count") +
  theme_minimal()
```

```{=tex}
\begin{center}
Figure 8: Heat Map of Patients on Medicare in  New York City Boroughs
\end{center}
```
Building on the insights from Plot 6, which highlighted the distribution of healthcare payment types among different racial groups, our focus shifted to a more localized context---New York City. This targeted analysis allows us to dissect the intricate layers of Medicaid distribution by race within the city's diverse boroughs.

In Plot 8, the heatmap provides a stark visualization of racial disparities across NYC boroughs. The variance in color intensity, from light to dark red, denotes the number of Medicaid recipients, revealing a pronounced concentration in Kings (Brooklyn), particularly among Black/African American individuals. This contrast is particularly noteworthy when compared to Manhattan, where a higher count of White individuals is evident. The heatmap's gradient effectively communicates the disparity in Medicaid dependence between these two populous boroughs. Meanwhile, Richmond (Staten Island) shows markedly lower numbers for both racial groups, hinting at different underlying socioeconomic factors at play. The Bronx and Queens present a more balanced distribution, suggesting a more equitable spread of Medicaid coverage across racial lines in these areas.

## Plot 9: New York City Map Analysis

```{r, fig.height = 6, fig.width = 7, message = FALSE, warning = FALSE}
#| echo: false
library(stringr)
library(dplyr)
library(grid)
library(gridExtra)
library(RSQLite)
library(shiny)
library(DBI)
library(RSQLite)
library(ggplot2)
library(sf)
library(waffle)
library(patchwork)
library(tigris)
library(ggplot2)
library(viridis)
library(lubridate)
library(sf)
library(DBI)
library(flextable)

db_path <- "finalDB.db"
con <- dbConnect(SQLite(), db_path)

# Query the data
query <- "
  SELECT `HospitalCounty`, Race, COUNT(*) as count
  FROM `2013data`
  WHERE `HealthServiceArea` = 'New York City' 
    AND Race IN ('Black/African American', 'White')
  GROUP BY `HospitalCounty`, `Race`
"
data <- dbGetQuery(con, query)

# Replace 'Manhattan' with 'New York' to match the shapefile data
data$HospitalCounty <- gsub("Manhattan", "New York", data$HospitalCounty)

# Disconnect from the database
dbDisconnect(con)

# Retrieve the NYC boroughs shape data and filter for the five boroughs
options(tigris_use_cache = TRUE)
ny_counties <- tigris::counties(state = "NY", cb = TRUE) %>% st_as_sf()

nyc_boroughs <- ny_counties[ny_counties$NAME %in% c("Bronx", "Kings", "New York", "Queens", "Richmond"), ]

# Merge the data with the nyc_boroughs spatial object
data_sf <- merge(nyc_boroughs, data, by.x = "NAME", by.y = "HospitalCounty", all.x = TRUE)

# Compute the centroids for the NYC boroughs for plotting circles
data_sf$centroid <- st_centroid(data_sf)

# Create a column with the X and Y coordinates of the centroids
data_sf$X <- st_coordinates(data_sf$centroid)[, "X"]
data_sf$Y <- st_coordinates(data_sf$centroid)[, "Y"]

# Plotting side-by-side maps
ggplot(data_sf) +
  geom_sf(aes(fill = NAME), color = "grey60", size = 0.5) +
  geom_point(aes(x = X, y = Y, size = count, color = Race), alpha = 0.7, show.legend = "point") +
  facet_wrap(~Race, ncol = 2) +
  scale_color_manual(values = c("Black/African American" = "blue", "White" = "red"), name = "Race") +
  scale_size_continuous(name = "Count", breaks = c(10000,20000,30000,40000,50000)) +
  labs(title = "Number of Black vs. White Individuals on Medicaid in NYC Boroughs",
       subtitle = "Size of point indicates count, color indicates county",
       fill = "Borough Name") + # Change the legend title for the fill aesthetic
  theme_minimal() +
  theme(legend.position = "right", axis.title.x = element_blank(), axis.title.y = element_blank(),
        axis.text.x = element_blank(), axis.text.y = element_blank(), axis.ticks = element_blank())

```

```{=tex}
\begin{center}
Figure 9: Map of Patients on Medicare in  New York City Boroughs
\end{center}
```
Plot 9 deepens this exploration with a cartographic depiction that merges Medicaid data with the geographic layout of NYC. The boroughs are color-coded, and within each, circles of varying sizes represent the count of Medicaid recipients, with the color designating the race---blue for Black/African American and red for White. The visualization brings to light the sheer volume of Black/African American Medicaid beneficiaries in Brooklyn, as indicated by the dominance of the blue circles. In contrast, Manhattan's red circles point to a higher number of White individuals on Medicaid. This map is more than a visual aid; it encapsulates the demographic disparities in healthcare access and provides a spatial dimension to the quantitative data. For stakeholders, this map is a call to action, highlighting areas where healthcare policies and programs may need to be adjusted to address the specific needs of each borough's population, ensuring a more equitable healthcare system in one of the world's most diverse cities.

In conclusion, the sequence of plots from our analysis paints a telling picture of the healthcare payment landscape in New York City, marked by significant racial and geographic disparities. The pie chart in Plot 6 laid the foundation, showing distinct payment behaviors among racial groups. This was the impetus for a deeper dive into the local context, where the heatmap of Plot 7 highlighted stark contrasts in Medicaid distribution across boroughs, with Kings (Brooklyn) and Manhattan exhibiting pronounced disparities between Black/African American and White populations, respectively. Plot 8's map provided a vivid geographical perspective, reinforcing these disparities with visual cues that emphasize the concentration of Medicaid recipients in specific boroughs. Together, these visualizations not only underscore the existing inequities in healthcare coverage but also underscore the need for targeted policy interventions.

# Killer Plot

In our pursuit to enhance data transparency and support decision-making in healthcare, we introduce the Human Body Economic Diagram (HBED), a proposed analytical tool outlined in this report. The HBED represents a leap forward in medical data visualization, combining anatomical precision with economic analysis. It features an interactive silhouette of the human body, onto which data is mapped in an intuitive and accessible manner.

The HBED's core functionality lies in its ability to visually represent medical procedure frequencies and their associated costs on the human body. By using variably-sized circles, each corresponding to a different body part and scaled to indicate procedural frequency, and color-coding these circles to depict the average costs, the tool provides a quick, comparative view of the medical procedures landscape.

Complementing the diagram, a sophisticated dropdown menu will allow users to delve into the specifics of each anatomical region. Selecting a body part will reveal a detailed dashboard, presenting comprehensive metrics such as success rates of procedures, average recovery times, patient demographics, and regional cost variations. This granularity empowers users with the data needed to make informed decisions. The dropdown also includes Shiny elements to toggle between the year 2013 and 2021, and the body parts of head, chest, and torso.

Designed to be responsive and versatile, the HBED tool will be accessible across a range of devices, ensuring that whether a patient seeking cost transparency, a healthcare professional comparing procedural statistics, or a policymaker analyzing economic trends in healthcare, the information is readily available.

## Human Body Economic Diagram

```{r, fig.height= 3, fig.width=5, warning = FALSE, message = FALSE}
#| echo: false
library(shiny)
library(grid)
library(gridExtra)
library(scales)

query <- dbSendQuery(dcon,"
  SELECT *
  FROM '2021data';
  ")
  data_2021 <- dbFetch(query, -1)
  dbClearResult(query)
  query <- dbSendQuery(dcon,"
  SELECT *
  FROM '2013data';
  ")
  data_2013 <- dbFetch(query, -1)
  dbClearResult(query)

   # This function wraps your existing grid drawing code
  drawYourPlot <- function() {
    if(input$time == "2013"){
  cleaned_data <- data_2013
}
  if(input$time == "2021"){
  cleaned_data <- data_2021
  
}
     
  chest <- select(cleaned_data, APRMDCCode, TotalCharges, LengthofStay) %>% 
  filter(APRMDCCode %in% c(16, 5, 8, 4, 9, 21))

head <- select(cleaned_data, APRMDCCode, TotalCharges,LengthofStay) %>% 
  filter(APRMDCCode %in% c(20, 2, 1, 3, 10, 18, 19, 23))

stomach <- select(cleaned_data, APRMDCCode, TotalCharges, LengthofStay) %>% 
  filter(APRMDCCode %in% c(6, 13, 7, 11, 12, 17, 15, 24))

chest_count <- length(chest$APRMDCCode)
head_count <- length(head$APRMDCCode)
stomach_count <- length(stomach$APRMDCCode)
total_count <- length(cleaned_data$APRDRGCode)

draw_bed<- function(){
#bed frame
grid.draw(rectGrob(x = 0.80, y = 0.3, width = 0.375, height = 0.1, gp = gpar(fill = "brown3", col = "brown3", lwd = 2)))
#mattress
grid.draw(rectGrob(x = 0.80, y = 0.325, width = 0.35, height = 0.12, gp = gpar(fill = "gray", col = "gray", lwd = 2)))
#pillow
grid.draw(rectGrob(x = 0.675, y = 0.38, width = 0.125, height = 0.05, gp = gpar(fill = "gray", col = "darkgray", lwd = 2)))

#left headboard
grid.draw(rectGrob(x = 0.6, y = 0.35, width = 0.05, height = 0.35, gp = gpar(fill = "brown3", col = "brown3", lwd = 2)))

#right headboard
grid.draw(rectGrob(x = 0.975, y = 0.325, width = 0.05, height = 0.3, gp = gpar(fill = "brown3", col = "brown3", lwd = 2)))

#blanket
grid.draw(rectGrob(x = 0.85, y = 0.325, width = 0.2, height = 0.135, gp = gpar(fill = "lightpink", col = "pink2", lwd = 2)))

grid.text("Average Charge per Day", x = 0.8, y = 0.5, just = "centre", gp = gpar(fontsize = 10))

if(input$bodyPart == "Head"){
  grid.text(round(sum(head$TotalCharges)/sum(head$LengthofStay),2), x = 0.85, y = 0.33, just = "centre")
}
else if(input$bodyPart == "Chest"){
   grid.text(round(sum(chest$TotalCharges)/sum(chest$LengthofStay), 2), x = 0.85, y = 0.33, just = "centre")
}
else if(input$bodyPart == "Torso"){
   grid.text(round(sum(stomach$TotalCharges)/sum(stomach$LengthofStay), 2), x = 0.85, y = 0.33, just = "centre")
  }
}
head_gp <- gpar(fill = "white")
body_gp <- gpar(fill = "black")
arms_gp <- gpar(fill = "white")
legs_gp <- gpar(fill = "khaki")
if(input$bodyPart == "Total"){
grid.newpage()
color_palette <- colorRampPalette(c("green", "red"))
#Drawing the gradient key
grad_key_height <- 0.5
grad_key_width <- 0.05
grad_key_x <- 0.7
grad_key_y <- 0.5

draw_vertical_rectangle <- function(x, y, width, height, gp = gpar()) {
  grid.rect(x = x - width / 2, y = y - height / 2, width = width, height = height, gp = gp)
}

grid.rect(x = grad_key_x-.025, y = grad_key_y-0.005, width = grad_key_width, height = grad_key_height, gp = gpar(col = "black"))


colors <- color_palette(100)
for (i in 1:100) {
  rect_gp <- gpar(fill = colors[i], col = NA)
  y_pos <- grad_key_y - (grad_key_height / 2) + ((i - 1) / 100) * grad_key_height
  draw_vertical_rectangle(x = grad_key_x, y = y_pos, width = grad_key_width, height = grad_key_height / 100, gp = rect_gp)
}
# Add labels to the gradient key
grid.text("$", x = grad_key_x-0.015, y = grad_key_y - (grad_key_height / 2) - 0.02, just = "centre")
grid.text("$$$", x = grad_key_x-0.015, y = grad_key_y + (grad_key_height / 2) + 0.02, just = "centre")
grid.text("Costs", x = grad_key_x-0.015, y = grad_key_y + (grad_key_height / 2) + 0.1, just = "centre")



get_color <- function(count, max_count) {
  # Assuming 'color_palette' is a function or vector of colors that returns a color based on the index
  normalized_count <- count/max_count
  colors <- colorRampPalette(c("green", "yellow", "orange", "orange", "red"))(100)  # Blue for less, Red for more
  color_index <- max(1, ceiling(normalized_count*100))
  return(colors[color_index])
}
draw_circle <- function(x, y, radius, gp = gpar()) {
  grid.circle(x = x, y = y, r = radius, gp = gp)
}



max_group_cost <- max(mean(head$TotalCharges), mean(chest$TotalCharges), mean(stomach$TotalCharges))
head_count_gp <- gpar(fill = get_color(mean(head$TotalCharges), max_group_cost))
chest_count_gp <- gpar(fill = get_color(mean(chest$TotalCharges), max_group_cost))
stomach_count_gp <- gpar(fill = get_color(mean(stomach$TotalCharges), max_group_cost))

draw_vertical_rectangle(x = 0.3, y = 0.75, width = 0.1, height = 0.35, gp = arms_gp) # this is neck
draw_circle(x = 0.25, y = 0.78, radius = 0.11, gp = head_gp) # this is head
draw_vertical_rectangle(x = 0.35, y = 0.65, width = 0.2, height = 0.35, gp = body_gp) # this is body
draw_vertical_rectangle(x = 0.15, y = 0.65, width = 0.05, height = 0.35, gp = arms_gp) # this is left arm

draw_circle(0.25,0.78, (head_count/total_count)/10, head_count_gp)
draw_circle(0.30,0.60, (chest_count/total_count)/10, chest_count_gp)
draw_circle(0.25,0.43, (stomach_count/total_count)/10, stomach_count_gp)


draw_circle(0.85,.28, .03)
draw_circle(0.85,.36, .04)
draw_circle(0.85,.45, .045)
draw_circle(0.85,.555, .0525)
draw_circle(0.85,.68, .06)
grid.text("Less", x = 0.85, y = grad_key_y - (grad_key_height / 2) - 0.02, just = "centre")
grid.text("More", x = 0.85, y = grad_key_y + (grad_key_height / 2) + 0.02, just = "centre")
grid.text("# of Cases", x = 0.85, y = grad_key_y + (grad_key_height / 2) + 0.1, just = "centre")




draw_vertical_rectangle(x = 0.4, y = 0.65, width = 0.05, height = 0.35, gp = arms_gp) # this is right arm
draw_vertical_rectangle(x = 0.25, y = 0.35, width = 0.1, height = 0.3, gp = legs_gp) # this is left leg
draw_vertical_rectangle(x = 0.35, y = 0.35, width = 0.1, height = 0.3, gp = legs_gp) # this is right leg
grid.ellipse(x = 0.25, y = 0.88, size = 9, ar = 4, angle = 0, gp = gpar(fill = "black"))
}
    # Here you would add additional grid drawing code based on the input$bodyPart
    # For example:
    else if (input$bodyPart == "Head") {
      # Add grid elements specific to the head
      grid.newpage()

grid.circle(x = 0.25, y = 0.5, r = 0.35, gp = gpar(fill = "white", col = "black", lwd = 3))
grid.lines(x = c(0.15), y = c(0,0.19), 
           gp = gpar(col = "black", lwd = 3))
grid.lines(x = c(0.35), y = c(0,0.19), 
           gp = gpar(col = "black", lwd = 3))

colors <- colorRampPalette(c("red", "yellow","green"))(1000)
num_circles <- length(colors)

# CIRCLE
circle_radius <- 0.1
x_center <- 0.80
y_center <- 0.75

# GRADIETN FOR CIRCLE
for (i in 1:num_circles) {
  color <- colors[i]
  angle <- seq(0, pi, length.out = num_circles + 1)[i]
  x <- x_center + circle_radius * cos(angle) 
  y <- y_center + circle_radius * sin(angle) 
  #grid.draw()
  grid.circle(x = x, y = y, r = 50 / num_circles, gp = gpar(fill = color, col = color))
}
  #grid.rect(x = 0.3, y = 0.25, gp = gpar(fill = "white", col = "white"), width = 2, height = .5)
  # LINES for APR Code
# 4
grid.lines(x = c(0.8, 0.9), y = c(0.7, .8), 
           gp = gpar(col = "black", lwd = 3))

grid.ellipse(x = 0.25, y = 0.85, size = 30, ar = 4, angle = 0, gp = gpar(fill = "black"))
grid.text("APR Severity Level", x= 0.8, y = 0.95, just = "centre")
draw_bed()


    } else if (input$bodyPart == "Torso") {
      # Add grid elements specific to the torso
      grid.newpage()

      draw_circle <- function(x, y, radius, gp = gpar()) {
  grid.circle(x = x, y = y, r = radius, gp = gp)
}
draw_vertical_rectangle <- function(x, y, width, height, gp = gpar()) {
  grid.rect(x = x - width / 2, y = y - height / 2, width = width, height = height, gp = gp)
}
draw_vertical_rectangle(x = 0.45, y = 0.95, width = 0.4, height = 0.6, gp = body_gp) # this is body
draw_vertical_rectangle(x = 0.25, y = 0.35, width = 0.2, height = 0.4, gp = legs_gp) # this is left leg
draw_vertical_rectangle(x = 0.45, y = 0.35, width = 0.2, height = 0.4, gp = legs_gp) # this is right leg


colors <- colorRampPalette(c("red", "yellow","green"))(1000)
num_circles <- length(colors)

# CIRCLE
circle_radius <- 0.1
x_center <- 0.80
y_center <- 0.75

# GRADIETN FOR CIRCLE
for (i in 1:num_circles) { 
  color <- colors[i]
  angle <- seq(0, pi, length.out = num_circles + 1)[i]
  x <- x_center + circle_radius * cos(angle) 
  y <- y_center + circle_radius * sin(angle) 
  grid.circle(x = x, y = y, r = 50 / num_circles, gp = gpar(fill = color, col = color))
}
# LINES for APR Code

  # 2
grid.lines(x = c(0.75, .8), y = c(0.85, .7), 
           gp = gpar(col = "black", lwd = 3))

grid.text("APR Severity Level", x= 0.8, y = 0.95, just = "centre")
draw_bed()
    } else if (input$bodyPart == "Chest") {
      # Add grid elements specific to the chest
      grid.newpage()
draw_circle <- function(x, y, radius, gp = gpar()) {
  grid.circle(x = x, y = y, r = radius, gp = gp)
}
draw_vertical_rectangle <- function(x, y, width, height, gp = gpar()) {
  grid.rect(x = x - width / 2, y = y - height / 2, width = width, height = height, gp = gp)
}
draw_vertical_rectangle(x = 0.4, y = 0.55, width = 0.3, height = 0.6, gp = body_gp) # this is body
draw_vertical_rectangle(x = 0.10, y = 0.55, width = 0.05, height = 0.4, gp = arms_gp) # this is left arm
draw_vertical_rectangle(x = 0.45, y = 0.55, width = 0.05, height = 0.4, gp = arms_gp) # this is right arm


colors <- colorRampPalette(c("red", "yellow","green"))(1000)
num_circles <- length(colors)

# CIRCLE
circle_radius <- 0.1
x_center <- 0.80
y_center <- 0.75

# GRADIENT FOR CIRCLE
for (i in 1:num_circles) { 
  color <- colors[i]
  angle <- seq(0, pi, length.out = num_circles + 1)[i]
  x <- x_center + circle_radius * cos(angle) 
  y <- y_center + circle_radius * sin(angle) 
  grid.circle(x = x, y = y, r = 50 / num_circles, gp = gpar(fill = color, col = color))
}
# LINES for APR Code
#3
grid.lines(x = c(0.8, .85), y = c(0.7, .85), 
           gp = gpar(col = "black", lwd = 3))

grid.text("APR Severity Level", x= 0.8, y = 0.95, just = "centre")
draw_bed()
    }
  }
  
  input <- data.frame(time  = "2013",
                  bodyPart= "Total"
                  )

    drawYourPlot()

```

```{=tex}
\begin{center}
Figure 10: Initial Screen of HBED with Cases and Costs
\end{center}
```
In Figure 10 of the Human Body Economic Diagram (HBED) for 2013, colored circles on the human silhouette represent the average cost of medical procedures for the head, torso, and chest. The red circle on the head indicates high-cost procedures, likely due to specialized surgeries. The torso's orange circle suggests moderate costs, possibly from a range of surgical interventions, while the yellow circle on the chest points to lower costs, associated with more routine procedures. These color-coded circles quickly convey the cost disparities of medical procedures across different body regions, encapsulating the economic aspect of healthcare in 2013.

```{r, fig.height= 3, fig.width= 5, warning = FALSE, message = FALSE}
#| echo: false
library(shiny)
library(grid)
library(gridExtra)
library(scales)

query <- dbSendQuery(dcon,"
  SELECT *
  FROM '2021data';
  ")
  data_2021 <- dbFetch(query, -1)
  dbClearResult(query)
  query <- dbSendQuery(dcon,"
  SELECT *
  FROM '2013data';
  ")
  data_2013 <- dbFetch(query, -1)
  dbClearResult(query)

   # This function wraps your existing grid drawing code
  drawYourPlot <- function() {
    if(input$time == "2013"){
  cleaned_data <- data_2013
}
  if(input$time == "2021"){
  cleaned_data <- data_2021
  
}
     
  chest <- select(cleaned_data, APRMDCCode, TotalCharges, LengthofStay) %>% 
  filter(APRMDCCode %in% c(16, 5, 8, 4, 9, 21))

head <- select(cleaned_data, APRMDCCode, TotalCharges,LengthofStay) %>% 
  filter(APRMDCCode %in% c(20, 2, 1, 3, 10, 18, 19, 23))

stomach <- select(cleaned_data, APRMDCCode, TotalCharges, LengthofStay) %>% 
  filter(APRMDCCode %in% c(6, 13, 7, 11, 12, 17, 15, 24))

chest_count <- length(chest$APRMDCCode)
head_count <- length(head$APRMDCCode)
stomach_count <- length(stomach$APRMDCCode)
total_count <- length(cleaned_data$APRDRGCode)

draw_bed<- function(){
#bed frame
grid.draw(rectGrob(x = 0.80, y = 0.3, width = 0.375, height = 0.1, gp = gpar(fill = "brown3", col = "brown3", lwd = 2)))
#mattress
grid.draw(rectGrob(x = 0.80, y = 0.325, width = 0.35, height = 0.12, gp = gpar(fill = "gray", col = "gray", lwd = 2)))
#pillow
grid.draw(rectGrob(x = 0.675, y = 0.38, width = 0.125, height = 0.05, gp = gpar(fill = "gray", col = "darkgray", lwd = 2)))

#left headboard
grid.draw(rectGrob(x = 0.6, y = 0.35, width = 0.05, height = 0.35, gp = gpar(fill = "brown3", col = "brown3", lwd = 2)))

#right headboard
grid.draw(rectGrob(x = 0.975, y = 0.325, width = 0.05, height = 0.3, gp = gpar(fill = "brown3", col = "brown3", lwd = 2)))

#blanket
grid.draw(rectGrob(x = 0.85, y = 0.325, width = 0.2, height = 0.135, gp = gpar(fill = "lightpink", col = "pink2", lwd = 2)))

grid.text("Average Charge per Day", x = 0.8, y = 0.5, just = "centre", gp = gpar(fontsize = 10))

if(input$bodyPart == "Head"){
  grid.text(round(sum(head$TotalCharges)/sum(head$LengthofStay),2), x = 0.85, y = 0.33, just = "centre")
}
else if(input$bodyPart == "Chest"){
   grid.text(round(sum(chest$TotalCharges)/sum(chest$LengthofStay), 2), x = 0.85, y = 0.33, just = "centre")
}
else if(input$bodyPart == "Torso"){
   grid.text(round(sum(stomach$TotalCharges)/sum(stomach$LengthofStay), 2), x = 0.85, y = 0.33, just = "centre")
  }
}
head_gp <- gpar(fill = "white")
body_gp <- gpar(fill = "black")
arms_gp <- gpar(fill = "white")
legs_gp <- gpar(fill = "khaki")
if(input$bodyPart == "Total"){
grid.newpage()
color_palette <- colorRampPalette(c("green", "red"))
#Drawing the gradient key
grad_key_height <- 0.5
grad_key_width <- 0.05
grad_key_x <- 0.7
grad_key_y <- 0.5

draw_vertical_rectangle <- function(x, y, width, height, gp = gpar()) {
  grid.rect(x = x - width / 2, y = y - height / 2, width = width, height = height, gp = gp)
}

grid.rect(x = grad_key_x-.025, y = grad_key_y-0.005, width = grad_key_width, height = grad_key_height, gp = gpar(col = "black"))


colors <- color_palette(100)
for (i in 1:100) {
  rect_gp <- gpar(fill = colors[i], col = NA)
  y_pos <- grad_key_y - (grad_key_height / 2) + ((i - 1) / 100) * grad_key_height
  draw_vertical_rectangle(x = grad_key_x, y = y_pos, width = grad_key_width, height = grad_key_height / 100, gp = rect_gp)
}
# Add labels to the gradient key
grid.text("$", x = grad_key_x-0.015, y = grad_key_y - (grad_key_height / 2) - 0.02, just = "centre")
grid.text("$$$", x = grad_key_x-0.015, y = grad_key_y + (grad_key_height / 2) + 0.02, just = "centre")
grid.text("Costs", x = grad_key_x-0.015, y = grad_key_y + (grad_key_height / 2) + 0.1, just = "centre")



get_color <- function(count, max_count) {
  # Assuming 'color_palette' is a function or vector of colors that returns a color based on the index
  normalized_count <- count/max_count
  colors <- colorRampPalette(c("green", "yellow", "orange", "orange", "red"))(100)  # Blue for less, Red for more
  color_index <- max(1, ceiling(normalized_count*100))
  return(colors[color_index])
}
draw_circle <- function(x, y, radius, gp = gpar()) {
  grid.circle(x = x, y = y, r = radius, gp = gp)
}



max_group_cost <- max(mean(head$TotalCharges), mean(chest$TotalCharges), mean(stomach$TotalCharges))
head_count_gp <- gpar(fill = get_color(mean(head$TotalCharges), max_group_cost))
chest_count_gp <- gpar(fill = get_color(mean(chest$TotalCharges), max_group_cost))
stomach_count_gp <- gpar(fill = get_color(mean(stomach$TotalCharges), max_group_cost))

draw_vertical_rectangle(x = 0.3, y = 0.75, width = 0.1, height = 0.35, gp = arms_gp) # this is neck
draw_circle(x = 0.25, y = 0.78, radius = 0.11, gp = head_gp) # this is head
draw_vertical_rectangle(x = 0.35, y = 0.65, width = 0.2, height = 0.35, gp = body_gp) # this is body
draw_vertical_rectangle(x = 0.15, y = 0.65, width = 0.05, height = 0.35, gp = arms_gp) # this is left arm

draw_circle(0.25,0.78, (head_count/total_count)/10, head_count_gp)
draw_circle(0.30,0.60, (chest_count/total_count)/10, chest_count_gp)
draw_circle(0.25,0.43, (stomach_count/total_count)/10, stomach_count_gp)


draw_circle(0.85,.28, .03)
draw_circle(0.85,.36, .04)
draw_circle(0.85,.45, .045)
draw_circle(0.85,.555, .0525)
draw_circle(0.85,.68, .06)
grid.text("Less", x = 0.85, y = grad_key_y - (grad_key_height / 2) - 0.02, just = "centre")
grid.text("More", x = 0.85, y = grad_key_y + (grad_key_height / 2) + 0.02, just = "centre")
grid.text("# of Cases", x = 0.85, y = grad_key_y + (grad_key_height / 2) + 0.1, just = "centre")




draw_vertical_rectangle(x = 0.4, y = 0.65, width = 0.05, height = 0.35, gp = arms_gp) # this is right arm
draw_vertical_rectangle(x = 0.25, y = 0.35, width = 0.1, height = 0.3, gp = legs_gp) # this is left leg
draw_vertical_rectangle(x = 0.35, y = 0.35, width = 0.1, height = 0.3, gp = legs_gp) # this is right leg
grid.ellipse(x = 0.25, y = 0.88, size = 9, ar = 4, angle = 0, gp = gpar(fill = "black"))
}
    # Here you would add additional grid drawing code based on the input$bodyPart
    # For example:
    else if (input$bodyPart == "Head") {
      # Add grid elements specific to the head
      grid.newpage()

grid.circle(x = 0.25, y = 0.5, r = 0.35, gp = gpar(fill = "white", col = "black", lwd = 3))
grid.lines(x = c(0.15), y = c(0,0.19), 
           gp = gpar(col = "black", lwd = 3))
grid.lines(x = c(0.35), y = c(0,0.19), 
           gp = gpar(col = "black", lwd = 3))

colors <- colorRampPalette(c("red", "yellow","green"))(1000)
num_circles <- length(colors)

# CIRCLE
circle_radius <- 0.1
x_center <- 0.80
y_center <- 0.75

# GRADIETN FOR CIRCLE
for (i in 1:num_circles) {
  color <- colors[i]
  angle <- seq(0, pi, length.out = num_circles + 1)[i]
  x <- x_center + circle_radius * cos(angle) 
  y <- y_center + circle_radius * sin(angle) 
  #grid.draw()
  grid.circle(x = x, y = y, r = 50 / num_circles, gp = gpar(fill = color, col = color))
}
  #grid.rect(x = 0.3, y = 0.25, gp = gpar(fill = "white", col = "white"), width = 2, height = .5)
  # LINES for APR Code
# 4
grid.lines(x = c(0.8, 0.9), y = c(0.7, .8), 
           gp = gpar(col = "black", lwd = 3))

grid.ellipse(x = 0.25, y = 0.85, size = 20, ar = 4, angle = 0, gp = gpar(fill = "black"))
grid.text("APR Severity Level", x= 0.8, y = 0.95, just = "centre")
draw_bed()


    } else if (input$bodyPart == "Torso") {
      # Add grid elements specific to the torso
      grid.newpage()

      draw_circle <- function(x, y, radius, gp = gpar()) {
  grid.circle(x = x, y = y, r = radius, gp = gp)
}
draw_vertical_rectangle <- function(x, y, width, height, gp = gpar()) {
  grid.rect(x = x - width / 2, y = y - height / 2, width = width, height = height, gp = gp)
}
draw_vertical_rectangle(x = 0.45, y = 0.95, width = 0.4, height = 0.6, gp = body_gp) # this is body
draw_vertical_rectangle(x = 0.25, y = 0.35, width = 0.2, height = 0.4, gp = legs_gp) # this is left leg
draw_vertical_rectangle(x = 0.45, y = 0.35, width = 0.2, height = 0.4, gp = legs_gp) # this is right leg


colors <- colorRampPalette(c("red", "yellow","green"))(1000)
num_circles <- length(colors)

# CIRCLE
circle_radius <- 0.1
x_center <- 0.80
y_center <- 0.75

# GRADIETN FOR CIRCLE
for (i in 1:num_circles) { 
  color <- colors[i]
  angle <- seq(0, pi, length.out = num_circles + 1)[i]
  x <- x_center + circle_radius * cos(angle) 
  y <- y_center + circle_radius * sin(angle) 
  grid.circle(x = x, y = y, r = 50 / num_circles, gp = gpar(fill = color, col = color))
}
# LINES for APR Code

  # 2
grid.lines(x = c(0.75, .8), y = c(0.85, .7), 
           gp = gpar(col = "black", lwd = 3))

grid.text("APR Severity Level", x= 0.8, y = 0.95, just = "centre")
draw_bed()
    } else if (input$bodyPart == "Chest") {
      # Add grid elements specific to the chest
      grid.newpage()
draw_circle <- function(x, y, radius, gp = gpar()) {
  grid.circle(x = x, y = y, r = radius, gp = gp)
}
draw_vertical_rectangle <- function(x, y, width, height, gp = gpar()) {
  grid.rect(x = x - width / 2, y = y - height / 2, width = width, height = height, gp = gp)
}
draw_vertical_rectangle(x = 0.4, y = 0.55, width = 0.3, height = 0.6, gp = body_gp) # this is body
draw_vertical_rectangle(x = 0.10, y = 0.55, width = 0.05, height = 0.4, gp = arms_gp) # this is left arm
draw_vertical_rectangle(x = 0.45, y = 0.55, width = 0.05, height = 0.4, gp = arms_gp) # this is right arm


colors <- colorRampPalette(c("red", "yellow","green"))(1000)
num_circles <- length(colors)

# CIRCLE
circle_radius <- 0.1
x_center <- 0.80
y_center <- 0.75

# GRADIENT FOR CIRCLE
for (i in 1:num_circles) { 
  color <- colors[i]
  angle <- seq(0, pi, length.out = num_circles + 1)[i]
  x <- x_center + circle_radius * cos(angle) 
  y <- y_center + circle_radius * sin(angle) 
  grid.circle(x = x, y = y, r = 50 / num_circles, gp = gpar(fill = color, col = color))
}
# LINES for APR Code
#3
grid.lines(x = c(0.8, .85), y = c(0.7, .85), 
           gp = gpar(col = "black", lwd = 3))

grid.text("APR Severity Level", x= 0.8, y = 0.95, just = "centre")
draw_bed()
    }
  }
  
  input <- data.frame(time  = "2013",
                  bodyPart= "Head"
                  )

    drawYourPlot()

```

```{=tex}
\begin{center}
Figure 11: 2013 Dropdown of Head with HBED Data
\end{center}
```
Figure 11 of the HBED for 2013 shows an APR Severity Level gauge by the head silhouette, highlighting high-risk and complex medical procedures, with a needle pointing towards the more severe end. The bar chart indicates a daily average cost of \$5,366.11, signaling the significant expenses incurred by such specialized treatments, potentially involving cutting-edge technology and high-level expertise. This detailed economic and clinical information aids in strategic healthcare management and the formulation of policies to ensure the delivery of cost-effective yet high-quality head medical procedures. Moreover, it can serve as a benchmark for tracking cost trends and evaluating the impact of new technologies or treatment protocols over time.

```{r, fig.height= 3, fig.width= 5, warning = FALSE, message = FALSE}
#| echo: false
library(shiny)
library(grid)
library(gridExtra)
library(scales)

query <- dbSendQuery(dcon,"
  SELECT *
  FROM '2021data';
  ")
  data_2021 <- dbFetch(query, -1)
  dbClearResult(query)
  query <- dbSendQuery(dcon,"
  SELECT *
  FROM '2013data';
  ")
  data_2013 <- dbFetch(query, -1)
  dbClearResult(query)

   # This function wraps your existing grid drawing code
  drawYourPlot <- function() {
    if(input$time == "2013"){
  cleaned_data <- data_2013
}
  if(input$time == "2021"){
  cleaned_data <- data_2021
  
}
     
  chest <- select(cleaned_data, APRMDCCode, TotalCharges, LengthofStay) %>% 
  filter(APRMDCCode %in% c(16, 5, 8, 4, 9, 21))

head <- select(cleaned_data, APRMDCCode, TotalCharges,LengthofStay) %>% 
  filter(APRMDCCode %in% c(20, 2, 1, 3, 10, 18, 19, 23))

stomach <- select(cleaned_data, APRMDCCode, TotalCharges, LengthofStay) %>% 
  filter(APRMDCCode %in% c(6, 13, 7, 11, 12, 17, 15, 24))

chest_count <- length(chest$APRMDCCode)
head_count <- length(head$APRMDCCode)
stomach_count <- length(stomach$APRMDCCode)
total_count <- length(cleaned_data$APRDRGCode)

draw_bed<- function(){
#bed frame
grid.draw(rectGrob(x = 0.80, y = 0.3, width = 0.375, height = 0.1, gp = gpar(fill = "brown3", col = "brown3", lwd = 2)))
#mattress
grid.draw(rectGrob(x = 0.80, y = 0.325, width = 0.35, height = 0.12, gp = gpar(fill = "gray", col = "gray", lwd = 2)))
#pillow
grid.draw(rectGrob(x = 0.675, y = 0.38, width = 0.125, height = 0.05, gp = gpar(fill = "gray", col = "darkgray", lwd = 2)))

#left headboard
grid.draw(rectGrob(x = 0.6, y = 0.35, width = 0.05, height = 0.35, gp = gpar(fill = "brown3", col = "brown3", lwd = 2)))

#right headboard
grid.draw(rectGrob(x = 0.975, y = 0.325, width = 0.05, height = 0.3, gp = gpar(fill = "brown3", col = "brown3", lwd = 2)))

#blanket
grid.draw(rectGrob(x = 0.85, y = 0.325, width = 0.2, height = 0.135, gp = gpar(fill = "lightpink", col = "pink2", lwd = 2)))

grid.text("Average Charge per Day", x = 0.8, y = 0.5, just = "centre",gp = gpar(fontsize = 10))

if(input$bodyPart == "Head"){
  grid.text(round(sum(head$TotalCharges)/sum(head$LengthofStay),2), x = 0.85, y = 0.33, just = "centre")
}
else if(input$bodyPart == "Chest"){
   grid.text(round(sum(chest$TotalCharges)/sum(chest$LengthofStay), 2), x = 0.85, y = 0.33, just = "centre")
}
else if(input$bodyPart == "Torso"){
   grid.text(round(sum(stomach$TotalCharges)/sum(stomach$LengthofStay), 2), x = 0.85, y = 0.33, just = "centre")
  }
}
head_gp <- gpar(fill = "white")
body_gp <- gpar(fill = "black")
arms_gp <- gpar(fill = "white")
legs_gp <- gpar(fill = "khaki")
if(input$bodyPart == "Total"){
grid.newpage()
color_palette <- colorRampPalette(c("green", "red"))
#Drawing the gradient key
grad_key_height <- 0.5
grad_key_width <- 0.05
grad_key_x <- 0.7
grad_key_y <- 0.5

draw_vertical_rectangle <- function(x, y, width, height, gp = gpar()) {
  grid.rect(x = x - width / 2, y = y - height / 2, width = width, height = height, gp = gp)
}

grid.rect(x = grad_key_x-.025, y = grad_key_y-0.005, width = grad_key_width, height = grad_key_height, gp = gpar(col = "black"))


colors <- color_palette(100)
for (i in 1:100) {
  rect_gp <- gpar(fill = colors[i], col = NA)
  y_pos <- grad_key_y - (grad_key_height / 2) + ((i - 1) / 100) * grad_key_height
  draw_vertical_rectangle(x = grad_key_x, y = y_pos, width = grad_key_width, height = grad_key_height / 100, gp = rect_gp)
}
# Add labels to the gradient key
grid.text("$", x = grad_key_x-0.015, y = grad_key_y - (grad_key_height / 2) - 0.02, just = "centre")
grid.text("$$$", x = grad_key_x-0.015, y = grad_key_y + (grad_key_height / 2) + 0.02, just = "centre")
grid.text("Costs", x = grad_key_x-0.015, y = grad_key_y + (grad_key_height / 2) + 0.1, just = "centre")



get_color <- function(count, max_count) {
  # Assuming 'color_palette' is a function or vector of colors that returns a color based on the index
  normalized_count <- count/max_count
  colors <- colorRampPalette(c("green", "yellow", "orange", "orange", "red"))(100)  # Blue for less, Red for more
  color_index <- max(1, ceiling(normalized_count*100))
  return(colors[color_index])
}
draw_circle <- function(x, y, radius, gp = gpar()) {
  grid.circle(x = x, y = y, r = radius, gp = gp)
}



max_group_cost <- max(mean(head$TotalCharges), mean(chest$TotalCharges), mean(stomach$TotalCharges))
head_count_gp <- gpar(fill = get_color(mean(head$TotalCharges), max_group_cost))
chest_count_gp <- gpar(fill = get_color(mean(chest$TotalCharges), max_group_cost))
stomach_count_gp <- gpar(fill = get_color(mean(stomach$TotalCharges), max_group_cost))

draw_vertical_rectangle(x = 0.3, y = 0.75, width = 0.1, height = 0.35, gp = arms_gp) # this is neck
draw_circle(x = 0.25, y = 0.78, radius = 0.11, gp = head_gp) # this is head
draw_vertical_rectangle(x = 0.35, y = 0.65, width = 0.2, height = 0.35, gp = body_gp) # this is body
draw_vertical_rectangle(x = 0.15, y = 0.65, width = 0.05, height = 0.35, gp = arms_gp) # this is left arm

draw_circle(0.25,0.78, (head_count/total_count)/10, head_count_gp)
draw_circle(0.30,0.60, (chest_count/total_count)/10, chest_count_gp)
draw_circle(0.25,0.43, (stomach_count/total_count)/10, stomach_count_gp)


draw_circle(0.85,.28, .03)
draw_circle(0.85,.36, .04)
draw_circle(0.85,.45, .045)
draw_circle(0.85,.555, .0525)
draw_circle(0.85,.68, .06)
grid.text("Less", x = 0.85, y = grad_key_y - (grad_key_height / 2) - 0.02, just = "centre")
grid.text("More", x = 0.85, y = grad_key_y + (grad_key_height / 2) + 0.02, just = "centre")
grid.text("# of Cases", x = 0.85, y = grad_key_y + (grad_key_height / 2) + 0.1, just = "centre")




draw_vertical_rectangle(x = 0.4, y = 0.65, width = 0.05, height = 0.35, gp = arms_gp) # this is right arm
draw_vertical_rectangle(x = 0.25, y = 0.35, width = 0.1, height = 0.3, gp = legs_gp) # this is left leg
draw_vertical_rectangle(x = 0.35, y = 0.35, width = 0.1, height = 0.3, gp = legs_gp) # this is right leg
grid.ellipse(x = 0.25, y = 0.88, size = 9, ar = 4, angle = 0, gp = gpar(fill = "black"))
}
    # Here you would add additional grid drawing code based on the input$bodyPart
    # For example:
    else if (input$bodyPart == "Head") {
      # Add grid elements specific to the head
      grid.newpage()

grid.circle(x = 0.25, y = 0.5, r = 0.35, gp = gpar(fill = "white", col = "black", lwd = 3))
grid.lines(x = c(0.15), y = c(0,0.19), 
           gp = gpar(col = "black", lwd = 3))
grid.lines(x = c(0.35), y = c(0,0.19), 
           gp = gpar(col = "black", lwd = 3))

colors <- colorRampPalette(c("red", "yellow","green"))(1000)
num_circles <- length(colors)

# CIRCLE
circle_radius <- 0.1
x_center <- 0.80
y_center <- 0.75

# GRADIETN FOR CIRCLE
for (i in 1:num_circles) {
  color <- colors[i]
  angle <- seq(0, pi, length.out = num_circles + 1)[i]
  x <- x_center + circle_radius * cos(angle) 
  y <- y_center + circle_radius * sin(angle) 
  #grid.draw()
  grid.circle(x = x, y = y, r = 50 / num_circles, gp = gpar(fill = color, col = color))
}
  #grid.rect(x = 0.3, y = 0.25, gp = gpar(fill = "white", col = "white"), width = 2, height = .5)
  # LINES for APR Code
# 4
grid.lines(x = c(0.8, 0.9), y = c(0.7, .8), 
           gp = gpar(col = "black", lwd = 3))

grid.ellipse(x = 0.25, y = 0.85, size = 20, ar = 4, angle = 0, gp = gpar(fill = "black"))
grid.text("APR Severity Level", x= 0.8, y = 0.95, just = "centre")
draw_bed()


    } else if (input$bodyPart == "Torso") {
      # Add grid elements specific to the torso
      grid.newpage()

      draw_circle <- function(x, y, radius, gp = gpar()) {
  grid.circle(x = x, y = y, r = radius, gp = gp)
}
draw_vertical_rectangle <- function(x, y, width, height, gp = gpar()) {
  grid.rect(x = x - width / 2, y = y - height / 2, width = width, height = height, gp = gp)
}
draw_vertical_rectangle(x = 0.45, y = 0.95, width = 0.4, height = 0.6, gp = body_gp) # this is body
draw_vertical_rectangle(x = 0.25, y = 0.35, width = 0.2, height = 0.4, gp = legs_gp) # this is left leg
draw_vertical_rectangle(x = 0.45, y = 0.35, width = 0.2, height = 0.4, gp = legs_gp) # this is right leg


colors <- colorRampPalette(c("red", "yellow","green"))(1000)
num_circles <- length(colors)

# CIRCLE
circle_radius <- 0.1
x_center <- 0.80
y_center <- 0.75

# GRADIETN FOR CIRCLE
for (i in 1:num_circles) { 
  color <- colors[i]
  angle <- seq(0, pi, length.out = num_circles + 1)[i]
  x <- x_center + circle_radius * cos(angle) 
  y <- y_center + circle_radius * sin(angle) 
  grid.circle(x = x, y = y, r = 50 / num_circles, gp = gpar(fill = color, col = color))
}
# LINES for APR Code

  # 2
grid.lines(x = c(0.75, .8), y = c(0.85, .7), 
           gp = gpar(col = "black", lwd = 3))

grid.text("APR Severity Level", x= 0.8, y = 0.95, just = "centre")
draw_bed()
    } else if (input$bodyPart == "Chest") {
      # Add grid elements specific to the chest
      grid.newpage()
draw_circle <- function(x, y, radius, gp = gpar()) {
  grid.circle(x = x, y = y, r = radius, gp = gp)
}
draw_vertical_rectangle <- function(x, y, width, height, gp = gpar()) {
  grid.rect(x = x - width / 2, y = y - height / 2, width = width, height = height, gp = gp)
}
draw_vertical_rectangle(x = 0.4, y = 0.55, width = 0.3, height = 0.6, gp = body_gp) # this is body
draw_vertical_rectangle(x = 0.10, y = 0.55, width = 0.05, height = 0.4, gp = arms_gp) # this is left arm
draw_vertical_rectangle(x = 0.45, y = 0.55, width = 0.05, height = 0.4, gp = arms_gp) # this is right arm


colors <- colorRampPalette(c("red", "yellow","green"))(1000)
num_circles <- length(colors)

# CIRCLE
circle_radius <- 0.1
x_center <- 0.80
y_center <- 0.75

# GRADIENT FOR CIRCLE
for (i in 1:num_circles) { 
  color <- colors[i]
  angle <- seq(0, pi, length.out = num_circles + 1)[i]
  x <- x_center + circle_radius * cos(angle) 
  y <- y_center + circle_radius * sin(angle) 
  grid.circle(x = x, y = y, r = 50 / num_circles, gp = gpar(fill = color, col = color))
}
# LINES for APR Code
#3
grid.lines(x = c(0.8, .85), y = c(0.7, .85), 
           gp = gpar(col = "black", lwd = 3))

grid.text("APR Severity Level", x= 0.8, y = 0.95, just = "centre")
draw_bed()
    }
  }
  
  input <- data.frame(time  = "2021",
                  bodyPart= "Head"
                  )

    drawYourPlot()

```

```{=tex}
\begin{center}
Figure 12: 2021 Dropdown of Head with HBED Data
\end{center}
```
Transitioning to Figure 12, now shown as the 2021 Dropdown of Head with HBED Data, we see a significant change. The APR Severity Level remains a key feature, but the average daily charge has substantially increased to \$19,131.32. This stark increase could reflect several factors, such as advancements in medical technology, inflation, or changes in the healthcare market.

Both dropdowns indicate that, while severity may not have dramatically changed, the economic impact on patients undergoing head-related procedures has notably increased. Moreover, similar dropdowns for the torso and chest are available, allowing users to explore and compare procedural frequencies, severities, and costs across different body regions over time, providing a comprehensive economic overview of medical treatments in the HBED system.

# Conclusion

This project, through its meticulous analysis and innovative visualization techniques, has laid bare the complex tapestry of healthcare in New York City, revealing significant disparities along racial and geographic lines. The data-driven insights underscore an urgent need for targeted policy interventions to address these inequities.

As seen in our first two plots regarding the visualizations on the severity of illness, it becomes heavily omnipresent that there is an association with race and location. This adds to the discussion that there may be certain areas in the state of New York that may gain access to healthcare for more minor cases, as well as certain races and ethnicity that may not be receiving an adequate amount of care.

We then worked on uncovering the disparities that exist among in the charges and costs through our linear regression model, barplots for pregnant women and our facet density plots on age. This revealed that on multiple identifying factors and fronts that there is a striking disparity that is observed on the basis of costs and charges. This inequality reveals a deep-rooted issue of economic inequality that affects multiple individuals who are vulnerable in New York that requires a more sophisticated analysis of what can be done to ensure that costs reflect a more whole and fair system.

Then we presented visualizations that revealed stark contrasts in healthcare payment behaviors among different racial groups and across New York City boroughs. For instance, the pie chart in Plot 7 highlighted distinct payment behaviors by race, forming the basis for a more localized investigation. The heatmap of Plot 8 accentuated these disparities, particularly in Medicaid distribution between boroughs like Kings (Brooklyn) and Manhattan. Similarly, Plot 9 offered a geographical perspective, further emphasizing the concentration of Medicaid recipients and the racial disparities in healthcare access.

Our project's data-driven insights reveal that individuals from minority populations often encounter significant barriers in accessing quality healthcare. This is not just a matter of economics but also of systemic biases and historical neglect. For instance, our analysis using pie charts and heatmaps clearly demonstrates how Medicaid distribution and healthcare services are unevenly spread across New York City and Western New York, or when specifically looking into New York City there is some evidence favoring some boroughs over others. This uneven distribution often leaves minority populations in urban areas with limited access to essential healthcare services, compared to their white counterparts.

In conclusion, our project not only provides a detailed snapshot of New York's healthcare system but also serves as a call to action. It highlights the need for ongoing research, innovative data visualization tools, and policy reforms aimed at addressing healthcare disparities. By leveraging the power of data, we can pave the way for a more equitable and efficient healthcare system that caters to the needs of all New Yorkers, setting a precedent for healthcare systems globally.

\newpage

# Resources

2013 Dataset:

[https://www.health.ny.gov/statistics/vital_statistics/2013/](https://www.health.ny.gov/statistics/vital_statistics/2013/https://www.health.ny.gov/statistics/vital_statistics/2021/)

2021 Dataset:

[https://www.health.ny.gov/statistics/vital_statistics/2021/](https://www.health.ny.gov/statistics/vital_statistics/2013/https://www.health.ny.gov/statistics/vital_statistics/2021/)
